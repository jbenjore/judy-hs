TYPEMAP
Pvoid_t T_PVOID
Word_t* T_WORD_PTR
Word_t T_WORD
Str T_STR

INPUT
T_STR
    ($var.ptr) = SvPV($arg,($var.length))

T_PVOID

    /* It should never, ever happen that I get pointers that could
       suffer truncation because Judy always allocates everything and
       that's at the native size instead of perl's long long. */

    $var = (Pvoid_t)(SvOK($arg) ? (Word_t)SvUV($arg) : 0);

T_WORD_PTR
    /* It should never, ever happen that I get pointers that could
       suffer truncation because Judy always allocates everything and
       that's at the native size instead of perl's long long. */

    $var = INT2PTR($type,SvUV($arg));

T_WORD
    #if (LONGSIZE != IVSIZE) || (LONGSIZE != UVSIZE)

        /* Perl compiled with -Duse64bitints on a 32-bit machine has
           IV and UV defined as long long except this doesn't fit
           within a word. This potentially makes it easy to try to
           store values in Judy that can't be represented without
           upgrading the CPU. */

        if ( SvUV($arg) != (UV)(Word_t)SvUV($arg) ) {
            warn(\"(UV)%lld truncated to (Word_t)%ld\", SvUV($arg), (Word_t)SvUV($arg));
        }
        $var = (Word_t)SvUV($arg);
    #else
        $var = (Word_t)SvUV($arg);
    #endif
    /* This line added to get something I've forgotten about to line up properly in the generated C source */

OUTPUT
T_STR
    sv_setpvn($arg, $var.ptr, $var.length ? $var.length : strlen( $var.ptr ));

T_PVOID
    if ( SvOK($arg) ) {
            sv_setiv($arg,PTR2IV($var));
    }
    else {
            /* Handles the case when we're passed an undef */
            sv_setsv($arg,newSViv(PTR2IV($var)));
    }

T_WORD
    sv_setiv($arg, $var);

T_WORD_PTR
    sv_setiv($arg, PTR2IV($var));
